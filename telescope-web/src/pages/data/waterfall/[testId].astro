---
import Layout from '../../../layouts/Layout.astro';
import TopNav from '../../../components/TopNav.astro';
import DataNav from '../../../components/DataNav.astro';

const { testId } = Astro.params;

export const prerender = false;
---

<Layout title={`Waterfall - ${testId} - Telescope`}>
  <TopNav inactive="results" />
  <DataNav active="waterfall" testId={testId} />
  <section class="data-content">
    <h1>Waterfall</h1>
    <h2>View the waterfall of the test.</h2>
    <div id="waterfall-container" class="overview-section">
      <p>Loading waterfall data...</p>
    </div>
  </section>
</Layout>

<script>
  const testId = window.location.pathname.split('/').pop();
  
  async function loadWaterfall() {
    try {
      const harData = await fetch(`/api/results/${testId}/pageload.har`).then(r => r.ok ? r.json() : null);
      
      const container = document.getElementById('waterfall-container');
      if (!harData || !harData.log || !harData.log.entries) {
        container!.innerHTML = '<p>No waterfall data available for this test.</p>';
        return;
      }
      
      const entries = harData.log.entries;
      const pageStart = entries.length > 0 ? new Date(entries[0].startedDateTime).getTime() : 0;
      
      const resources = entries.map((entry: any, index: number) => {
        const request = entry.request || {};
        const response = entry.response || {};
        const timings = entry.timings || {};
        const startedDateTime = new Date(entry.startedDateTime).getTime();
        const relativeStart = startedDateTime - pageStart;
        
        return {
          index: index + 1,
          url: request.url || '',
          method: request.method || 'GET',
          status: response.status || 0,
          duration: entry.time || 0,
          startTime: relativeStart,
          size: response.bodySize || response.content?.size || 0,
        };
      });
      
      const maxTime = Math.max(...resources.map((r: any) => r.startTime + r.duration), 0);
      
      container!.innerHTML = `
        <h3>Network Requests (${resources.length})</h3>
        <div class="waterfall-table-container">
          <table class="waterfall-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Method</th>
                <th>URL</th>
                <th>Status</th>
                <th>Size</th>
                <th>Duration</th>
                <th>Timeline</th>
              </tr>
            </thead>
            <tbody>
              ${resources.map((resource: any) => {
                const leftPercent = (resource.startTime / maxTime) * 100;
                const widthPercent = (resource.duration / maxTime) * 100;
                
                return `
                  <tr>
                    <td>${resource.index}</td>
                    <td class="method">${escapeHtml(resource.method)}</td>
                    <td class="url" title="${escapeHtml(resource.url)}">${escapeHtml(resource.url.substring(0, 50))}${resource.url.length > 50 ? '...' : ''}</td>
                    <td class="status status-${Math.floor(resource.status / 100)}xx">${resource.status}</td>
                    <td>${formatBytes(resource.size)}</td>
                    <td>${formatTime(resource.duration)}</td>
                    <td>
                      <div class="timeline-bar" style="left: ${leftPercent}%; width: ${widthPercent}%;"></div>
                    </td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
    } catch (error) {
      console.error('Error loading waterfall:', error);
      document.getElementById('waterfall-container')!.innerHTML = 
        '<p style="color: rgba(255, 100, 100, 0.92);">Error loading waterfall data.</p>';
    }
  }
  
  function formatTime(ms: number): string {
    if (ms === 0 || !ms) return 'N/A';
    if (ms < 1000) return `${Math.round(ms)}ms`;
    return `${(ms / 1000).toFixed(2)}s`;
  }
  
  function formatBytes(bytes: number): string {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
  }
  
  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  loadWaterfall();
</script>

<style>
  .waterfall-table-container {
    margin-top: 16px;
    overflow-x: auto;
  }

  .waterfall-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }

  .waterfall-table thead {
    background: rgba(0, 0, 0, 0.03);
    border-bottom: 2px solid rgba(0, 0, 0, 0.12);
  }

  .waterfall-table th {
    padding: 12px;
    text-align: left;
    font-weight: 600;
    color: rgba(0, 0, 0, 0.92);
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .waterfall-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    color: rgba(0, 0, 0, 0.85);
    position: relative;
  }

  .waterfall-table tbody tr:hover {
    background: rgba(0, 0, 0, 0.02);
  }

  .method {
    text-transform: uppercase;
    font-weight: 600;
  }

  .url {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    max-width: 400px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .status {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    font-weight: 600;
  }

  .status-2xx {
    color: rgba(74, 222, 128, 0.9);
  }

  .status-3xx {
    color: rgba(251, 191, 36, 0.9);
  }

  .status-4xx,
  .status-5xx {
    color: rgba(239, 68, 68, 0.9);
  }

  .timeline-bar {
    position: relative;
    height: 24px;
    background: rgba(125, 211, 252, 0.4);
    border-radius: 4px;
    min-width: 2px;
  }
</style>
